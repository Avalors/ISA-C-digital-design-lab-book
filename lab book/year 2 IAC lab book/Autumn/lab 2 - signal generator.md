# Task 1: Simple sinewave generator

- In terms of hardware the sinewave generator consists of both a ROM containing sine values and a synchronous counter that iterates through each of these values on each rising clock edge by its count value corresponding to the address of the ROM.
![[Pasted image 20241025153709.png]]
## Counter.sv model:
- The only difference between this module and the usual count module, is the addition of the *incr* port signal.
- *incr* has the same number of bits as the address of the ROM, and will speed up the frequency of our signal generated by increasing the count at a faster rate and hence accessing larger addresses at a quicker rate.
> *f<sub>output</sub>* = *f<sub>clock</sub>* * *inc/256* 
```SystemVerilog
module counter #(
    parameter WIDTH = 8
)(
    input logic     clk,
    input logic     rst,
    input logic     en,
    input logic[WIDTH-1:0]  incr,
    output logic[WIDTH-1:0] count

);

always_ff @(posedge clk) begin
    if(rst) count <= 0;
    else if(en) count <= count + incr;
end

endmodule
```
- once count exceeds 255, it begins counting from 0 again automatically
## rom.sv (256x8) model
- This ROM can be adjusted by altering the parameter values on instantiation.
```SystemVerilog
module rom #(
    parameter   ADDRESS_WIDTH = 8,
                DATA_WIDTH = 8
)(
    //ports (interface signals for rom module)
    input logic     clk,
    input logic[ADDRESS_WIDTH-1:0]  addr,
    output logic[DATA_WIDTH-1:0]    dout
);
//internal ROM array
logic [DATA_WIDTH-1:0] rom_array [2**ADDRESS_WIDTH-1:0];

//initializes rom by loading with values stored in sinerom.mem
initial begin
    $display("Loading rom.");
    $readmemh("sinerom.mem", rom_array);
end;

  
always_ff @(posedge clk)
    //synchronous output
    dout <= rom_array[addr]; //non-blocking assignment
endmodule
```
- in this *inital begin-end* block it contains the loading of the rom from a file called *'sinerom.mem'*, this file is generated by *sinegen.py* python code that samples the value (in hex) of the sine wave 256 times and stores the value in *sinerom.mem* file.
- The *sinerom.mem* file stores the hex values that correspond to the sine wave in a 16x16 grid corresponding to the 256 memory locations that our ROM has available.
```python
import math
import string
f = open("sinerom.mem","w")
for i in range(256):
    v = int(math.cos(2*3.1416*i/256)*127+127) #range (0,256) due to multiplying and shifting w = 2*pi/256
    if (i+1)%16 == 0:
        s = "{hex:2X}\n"
    else:
        s = "{hex:2X} "
    f.write(s.format(hex=v))
  
f.close()
```
## Sinegen.sv structural model
- To implement  this system I used a structured description of this hardware using a top hierarchical module called *sinegen.sv* this contains instances of both the *counter.sv* and *rom.sv* modules, and connects them via the an internal address port:
```SystemVerilog
module sinegen #(
    parameter   A_WIDTH = 8,
                D_WIDTH = 8
)(
    input logic     clk,
    input logic     rst,
    input logic     en,
    input logic [A_WIDTH-1:0] incr,
    output logic [D_WIDTH-1:0] dout
);

logic [A_WIDTH-1:0] address;

counter #(A_WIDTH) addrCounter (
    .clk (clk),
    .rst (rst),
    .en (en),
    .incr (incr),
    .count (address)
);

rom #(A_WIDTH,D_WIDTH) sineRom (
    .clk (clk),
    .addr (address),
    .dout (dout)
);

endmodule
```

## Simulation of Simple sine wave generator
- To simulate and synthesize this model using Verilator and then executing the file on the vbuddy I had to write a test bench for this model.
- Since the system clock has as very high frequency and it only takes 256 cycles to complete a period of the sine wave, I set the number of cycles to 1000000 in the *sinegen_tb.cpp* testbench.
- Notably I set the *en* signal to *vbdFlag()* such that I would be able to toggle the generation on-off when pressing the EC11 rotary encoder button.
- On initializing the ports (interface signals) for the *sinegen.sv* model, I made sure to fix the *incr* signal value to 1.
- Using the *vbdGetKey() == 'q'* function I am able to easily exit the simulation by pressing q, which is registered by my vbuddy and hence shut off.
```cpp
#include "Vsinegen.h"
#include "verilated.h"
#include "verilated_vcd_c.h"
#include "vbuddy.cpp"
  
int main(int argc, char **argv, char **env){
    int i;
    int clk;

    Verilated::commandArgs(argc, argv);
    
    Vsinegen* top = new Vsinegen; //instantiates device under test
    
    Verilated::traceEverOn(true)
    VerilatedVcdC* tfp = new VerilatedVcdC;
    top->trace (tfp,99);
    tfp->open("sinegen.vcd");

    //init vbuddy
    if(vbdOpen() != 1) return(-1);
    vbdHeader("Lab-2:Sine generator");
    
    //initialize simulation inputs
    top->clk = 1;
    top->rst = 1;
    top->en = 1;
    top->incr = 1;

    for(i = 0; i < 1000000; i++){ //number of simulation cycles increased
        //dumps variables into VCD file
        for(clk = 0; clk < 2; clk++){
            tfp->dump (2*i+clk);
            top->clk = !top->clk;
            top->eval();
        }

        vbdPlot(int(top->dout),0,255);
        vbdCycle(i+1);
  
        top->rst = (i<2);
        top->en = vbdFlag();

        if(Verilated::gotFinish() || (vbdGetkey() == 'q')) exit(0);
    }
    vbdClose();
    tfp->close();
    exit(0);
}
```

- Changes made to the *doit.sh* file:
	- I added an if statement that checks if the port is found and to end the execution of the shell commands if it is found false and return an error to me if that happens.
	- This would make debugging much easier.
```shell
#!/bin/sh

#vbuddy connection established
if ! ~/Documents/iac/lab0-devtools/tools/attach_usb.sh; then
    echo "Error: Failed to attach USB with vbuddy."
    exit 1
fi

#cleanup
rm -rf obj_dir
rm -f sinegen.vcd

#verilator that generates mk file and Vcounter.cpp file
verilator -Wall --cc --trace sinegen.sv -exe sinegen_tb.cpp
  
#compiles mk file and cpp file into executable model of digital design
make -j -C obj_dir/ -f Vsinegen.mk Vsinegen
  
#run executable file
obj_dir/Vsinegen
```

## test
- Video:
![[WhatsApp Video 2024-10-25 at 16.20.50_75d42982.mp4]]

## Challange: changing *intr* using vbdValue()
- Simply added 
```cpp
top->intr = vbdValue(); //within the for loop with i.
```
- test:
![[WhatsApp Video 2024-10-25 at 20.08.19_83dbfb44.mp4]]

- It is clear to notice that as we increase *incr* by turning the rotary encoder clockwise, thought the frequency most evidently increases the dots become more clear and evident.
- This is due to the counter skipping through addresses at with larger and larger gaps producing a Sine wave with much worse resolution.

# Task2: sine and cosine dual wave generation
- In this task the objective is to generate 2 sinusoidal waves simulatenously, for which we can alter the phase difference between these two waves by turning the EC11 rotary encoder.

- I first implemented this by changing the hardware of the *rom.sv* module such that it becomes a dual-port ROM.
- The dual-port ROM will take two address inputs and output the corresponding data at those addresses.
```SystemVerilog
module rom #(
    parameter   ADDRESS_WIDTH = 8,
                DATA_WIDTH = 8

)(
    //ports (interface signals for rom module)
    input logic     clk,
    input logic[ADDRESS_WIDTH-1:0]  addr1, addr2,
    output logic[DATA_WIDTH-1:0]    dout1, dout2
);

//internal ROM array
logic [DATA_WIDTH-1:0] rom_array [2**ADDRESS_WIDTH-1:0];

//initializes rom by loading with values stored in sinerom.mem
initial begin
    $display("Loading rom.");
    $readmemh("sinerom.mem", rom_array);
end;
  
always_ff @(posedge clk) begin
    //synchronous output
    dout1 <= rom_array[addr1]; //non-blocking assignment
    dout2 <= rom_array[addr2];
    end
endmodule
```

- I made no changes to the *counter.sv* module, as I intend to implement the 2 differing address inputs by creating an additional interface signal called *phase[A_WIDTH-1:0]* which will be controlled via the rotary encoder value v (using *vbdValue()*).
- This phase value will be added to the count value, which will constitute the address for the second input (*addr2*).
- *sinegen.sv:*
```SystemVerilog
module sinegen #(
    parameter   A_WIDTH = 8,
                D_WIDTH = 8

)(
    input logic     clk,
    input logic     rst,
    input logic     en,
    input logic[A_WIDTH-1:0]    phase,
    input logic [A_WIDTH-1:0]   incr,
    output logic [D_WIDTH-1:0]  dout1,  dout2

);

logic [A_WIDTH-1:0] address;


counter #(A_WIDTH) addrCounter (
    .clk (clk),
    .rst (rst),
    .en (en),
    .incr (incr),
    .count (address)
);

rom #(A_WIDTH,D_WIDTH) sineRom (
    .clk (clk),
    .addr1 (address),
    .addr2 (address + phase),
    .dout1 (dout1),
    .dout2 (dout2)
);

endmodule
```

## Testbench for task 2:
- Noticably, since the entire sinewave is stored in 256 addresses within the ROM, antiphase will be reached when the phase = 128.
- The problem with this is that the rotary encoder only goes up to 100.
- To resolve this issue in the test bench, I multiplied the vbdValue() by 4, to result in v = 32 being the value at which the two sine waves are in anti-phase with each other.
```cpp
#include "Vsinegen.h"
#include "verilated.h"
#include "verilated_vcd_c.h"
#include "vbuddy.cpp"

int main(int argc, char **argv, char **env){
    int i;
    int clk;
    
    Verilated::commandArgs(argc, argv);

    Vsinegen* top = new Vsinegen; //instantiates device under test

    Verilated::traceEverOn(true);
    VerilatedVcdC* tfp = new VerilatedVcdC;
    top->trace (tfp,99);
    tfp->open("sinegen.vcd");

    //init vbuddy
    if(vbdOpen() != 1) return(-1);
    vbdHeader("Lab-2:Sine generator");
    //initialize simulation inputs
    
    top->clk = 1;
    top->rst = 1;
    top->en = 1;
    top->incr = 1; //increment is fixed at 1
    top->phase = vbdValue() * 4; //sets phase value

    for(i = 0; i < 1000000; i++){ //number of simulation cycles increased

        //dumps variables into VCD file
        for(clk = 0; clk < 2; clk++){
            tfp->dump (2*i+clk);
            top->clk = !top->clk;
            top->eval();
        }

        vbdPlot(int(top->dout1),0,255);
        vbdPlot(int(top->dout2),0,255);
        vbdCycle(i);

        top->rst = (i<2);
        top->en = vbdFlag();
        top->phase = vbdValue() * 4;
        if(Verilated::gotFinish() || (vbdGetkey() == 'q')) exit(0);

    }

    vbdClose();
    tfp->close();
    exit(0);
}
```
# Task 3: Using microphone on Vbuddy to generate a signal 
- This task makes us use a two port ram to temporarily store microphone input samples for which the vcdPlots the concurrently read microphone sample as well as a read sample from the RAM, which is created by using a counter with an offset.

- *counter.sv:
```SystemVerilog
module counter #(
    parameter WIDTH = 8
)(
    input logic     clk,
    input logic     rst,
    output logic[WIDTH-1:0] count
);

always_ff @(posedge clk) begin
    if(rst) count <= 0;
    else count <= count + 1;
end

endmodule
```

- *ram2ports.sv*:
```SystemVerilog
module ram2ports #(
    parameter   ADDRESS_WIDTH = 9,
                DATA_WIDTH = 8
)(
    input logic clk,
    input logic wr_en, rd_en,
    input logic [ADDRESS_WIDTH-1:0] wr_addr, rd_addr,
    input logic [DATA_WIDTH-1:0] din,
    output logic[DATA_WIDTH-1:0] dout
);

logic [DATA_WIDTH-1:0] ram_array [2**ADDRESS_WIDTH-1:0];

always_ff @(posedge clk)begin
    if(wr_en == 1'b1)
        ram_array[wr_addr] <= din;
    if(rd_en == 1'b1)
        dout <= ram_array[rd_addr];
end
endmodule
```

- *sigdelay.sv*: top level structural module
```SystemVerilog
module sigdelay #(
    parameter A_WIDTH = 9, D_WIDTH = 8  
)(
    input logic clk,
    input logic rst,
    input logic wr,
    input logic rd,
    input logic [D_WIDTH-1:0] mic_signal,
    input logic [A_WIDTH-1:0] offset,
    output logic [D_WIDTH-1:0] delayed_signal
);

logic [A_WIDTH-1:0] address;
logic [A_WIDTH-1:0] rd_addr;

assign rd_addr = (address >= offset) ? address - offset : (address + (2 ** A_WIDTH)) - offset;
//performs wrap around logic

counter #(A_WIDTH) addrCounter(
    .clk (clk),
    .rst (rst),
    .count (address)
);

ram2ports #(A_WIDTH,D_WIDTH) ram(
    .clk (clk),
    .wr_en (wr),
    .rd_en (rd),
    .wr_addr(address),
    .rd_addr(rd_addr),
    .din (mic_signal),
    .dout (delayed_signal)
);
endmodule

```

- *sigdelay_tb.cpp* test bench
```cpp
#include "verilated.h"
#include "verilated_vcd_c.h"
#include "Vsigdelay.h"
#include "vbuddy.cpp"     // include vbuddy code
#define MAX_SIM_CYC 1000000
#define ADDRESS_WIDTH 9
#define RAM_SZ pow(2,ADDRESS_WIDTH)
  
int main(int argc, char **argv, char **env) {
  int simcyc;     // simulation clock count
  int tick;       // each clk cycle has two ticks for two edges

  Verilated::commandArgs(argc, argv);
  // init top verilog instance
  Vsigdelay* top = new Vsigdelay;
  // init trace dump
  Verilated::traceEverOn(true);
  VerilatedVcdC* tfp = new VerilatedVcdC;
  top->trace (tfp, 99);
  tfp->open ("sigdelay.vcd");
  // init Vbuddy
  if (vbdOpen()!=1) return(-1);
  vbdHeader("L2T3:Delay");
  //vbdSetMode(1);        // Flag mode set to one-shot

  // initialize simulation input
  top->clk = 1;
  top->rst = 0;
  top->wr = 1;
  top->rd = 1;
  top->offset = 64;
  // intialize variables for analogue output
  vbdInitMicIn(RAM_SZ); //establishes the locations the samples of the mic can be stored
  // run simulation for MAX_SIM_CYC clock cycles
  for (simcyc=0; simcyc<MAX_SIM_CYC; simcyc++) {
    // dump variables into VCD file and toggle clock
    for (tick=0; tick<2; tick++) {
      tfp->dump (2*simcyc+tick);
      top->clk = !top->clk;
      top->eval ();
    }
    top->mic_signal = vbdMicValue();
    top->offset = abs(vbdValue());     // adjust delay by changing incr

    // plot RAM input/output, send sample to DAC buffer, and print cycle count
    vbdPlot(int (top->mic_signal), 0, 255);
    vbdPlot(int (top->delayed_signal), 0, 255);
    vbdCycle(simcyc);
  
    // either simulation finished, or 'q' is pressed
    if ((Verilated::gotFinish()) || (vbdGetkey()=='q'))
      exit(0);
  }

  vbdClose();     // ++++
  tfp->close();
  printf("Exiting\n");
  exit(0);
}
```

- Adjusted *doit.sh*  file
```shell
#!/bin/sh
#vbuddy connection established
if ! ~/Documents/iac/lab0-devtools/tools/attach_usb.sh; then
    echo "Error: Failed to attach USB with vbuddy."
    exit 1
fi

#cleanup
rm -rf obj_dir
rm -f sigdelay.vcd

#verilator that generates mk file and Vcounter.cpp file
verilator -Wall --cc --trace sigdelay.sv -exe sigdelay_tb.cpp

#compiles mk file and cpp file into executable model of digital design
make -j -C obj_dir/ -f Vsigdelay.mk Vsigdelay

#run executable file
obj_dir/Vsigdelay
```


## test: using 440Hz sine and square waves:

![[WhatsApp Video 2024-10-25 at 22.33.20_88a950b2.mp4]]

![[WhatsApp Video 2024-10-25 at 22.33.28_683a1219.mp4]]

